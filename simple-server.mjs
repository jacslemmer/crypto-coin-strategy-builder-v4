import express from "express"; import Database from "better-sqlite3"; import path from "path"; const app = express(); app.use(express.json()); const dbPath = path.join(process.cwd(), "data", "database", "working.sqlite"); const db = new Database(dbPath); console.log("Database initialized successfully"); db.exec("CREATE TABLE IF NOT EXISTS pairs (id TEXT PRIMARY KEY, symbol TEXT NOT NULL UNIQUE, rank INTEGER, market_cap REAL, volume REAL, price REAL, source TEXT NOT NULL, fetched_at INTEGER NOT NULL, is_active INTEGER NOT NULL DEFAULT 1)"); db.exec("CREATE TABLE IF NOT EXISTS jobs (id TEXT PRIMARY KEY, parent_job_id TEXT, job_type TEXT NOT NULL, status TEXT NOT NULL, parameters TEXT, progress INTEGER NOT NULL DEFAULT 0, total_items INTEGER, processed_items INTEGER, result TEXT, error TEXT, started_at INTEGER, completed_at INTEGER, created_at INTEGER NOT NULL, updated_at INTEGER NOT NULL, FOREIGN KEY (parent_job_id) REFERENCES jobs(id))"); const mockPairsData = [{ symbol: "BTC", rank: 1, marketCap: 1000000000000, volume: 50000000000, price: 50000 }, { symbol: "ETH", rank: 2, marketCap: 400000000000, volume: 30000000000, price: 3000 }]; app.post("/api/v1/pairs/fetch", async (req, res) => { try { const { limit = 15 } = req.body; console.log(`Fetching ${limit} pairs...`); const jobId = `job-${Date.now()}`; const jobStmt = db.prepare("INSERT INTO jobs (id, job_type, status, progress, total_items, processed_items, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"); jobStmt.run(jobId, "pairs_fetch", "in_progress", 0, limit, 0, Date.now(), Date.now()); const pairsToFetch = mockPairsData.slice(0, Math.min(limit, mockPairsData.length)); const insertStmt = db.prepare("INSERT OR REPLACE INTO pairs (id, symbol, rank, market_cap, volume, price, source, fetched_at, is_active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"); let insertedCount = 0; for (const pair of pairsToFetch) { const pairId = `pair-${pair.symbol}-${Date.now()}`; insertStmt.run(pairId, pair.symbol, pair.rank, pair.marketCap, pair.volume, pair.price, "mock", Date.now(), 1); insertedCount++; } const updateJobStmt = db.prepare("UPDATE jobs SET status = ?, progress = ?, processed_items = ?, result = ?, completed_at = ?, updated_at = ? WHERE id = ?"); updateJobStmt.run("completed", 100, insertedCount, JSON.stringify({ pairsFetched: insertedCount }), Date.now(), Date.now(), jobId); console.log(`Successfully fetched and stored ${insertedCount} pairs`); res.json({ message: "Pairs fetched successfully", limit, count: insertedCount, jobId, timestamp: new Date().toISOString() }); } catch (error) { console.error("Error fetching pairs:", error); res.status(500).json({ error: "Internal Server Error", message: "Failed to fetch pairs", timestamp: new Date().toISOString() }); } }); app.get("/api/v1/pairs", async (req, res) => { try { const limit = parseInt(req.query.limit) || 15; const stmt = db.prepare("SELECT * FROM pairs WHERE is_active = 1 ORDER BY rank ASC, market_cap DESC LIMIT ?"); const pairs = stmt.all(limit); res.json({ message: "Top pairs retrieved successfully", limit, count: pairs.length, pairs, timestamp: new Date().toISOString() }); } catch (error) { console.error("Error getting pairs:", error); res.status(500).json({ error: "Internal Server Error", message: "Failed to get pairs", timestamp: new Date().toISOString() }); } }); app.get("/health", (req, res) => { res.json({ status: "healthy", timestamp: new Date().toISOString(), database: "connected" }); }); const PORT = process.env.PORT || 4000; app.listen(PORT, () => { console.log(`Simple working server running on port ${PORT}`); console.log("This demonstrates the ACTUAL working functionality that was falsely reported"); });
