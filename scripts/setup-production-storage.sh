#!/bin/bash

# =============================================================================
# Crypto Coin Strategy Builder V4 - Production Storage Setup Script
# =============================================================================
# This script sets up the complete production storage infrastructure including:
# - Directory structure creation
# - Permission configuration
# - Environment file generation
# - Backup and health check scripts
# - Docker Compose override configuration
# =============================================================================

set -euo pipefail

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
DATA_DIR="${DATA_DIR:-./data}"
LOGS_DIR="${LOGS_DIR:-./logs}"
BUILD_DIR="${BUILD_DIR:-./build}"
BACKUP_DIR="${BACKUP_DIR:-./backups}"
MIGRATION_DIR="${MIGRATION_DIR:-./migrations}"

# Logging function
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO")
            echo -e "${BLUE}[${timestamp}] [INFO]${NC} $message"
            ;;
        "SUCCESS")
            echo -e "${GREEN}[${timestamp}] [SUCCESS]${NC} $message"
            ;;
        "WARNING")
            echo -e "${YELLOW}[${timestamp}] [WARNING]${NC} $message"
            ;;
        "ERROR")
            echo -e "${RED}[${timestamp}] [ERROR]${NC} $message"
            ;;
    esac
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Check if running as root
check_root() {
    if [[ $EUID -eq 0 ]]; then
        log "WARNING" "This script is running as root. This is not recommended for security reasons."
        read -p "Do you want to continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log "INFO" "Setup cancelled by user."
            exit 1
        fi
    fi
}

# Create directory structure
create_directories() {
    log "INFO" "Creating production storage directory structure..."
    
    # Main directories
    local dirs=(
        "$DATA_DIR/backend/r2"
        "$DATA_DIR/backend/screenshots"
        "$DATA_DIR/backend/charts"
        "$DATA_DIR/backend/analytics"
        "$DATA_DIR/database"
        "$DATA_DIR/redis"
        "$LOGS_DIR/backend"
        "$LOGS_DIR/nginx"
        "$BUILD_DIR/frontend"
        "$BACKUP_DIR"
        "$MIGRATION_DIR"
    )
    
    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            log "SUCCESS" "Created directory: $dir"
        else
            log "INFO" "Directory already exists: $dir"
        fi
    done
}

# Set permissions and ownership
set_permissions() {
    log "INFO" "Setting directory permissions and ownership..."
    
    # Get current user and group
    local current_user=$(whoami)
    local current_group=$(id -gn)
    
    # Set ownership
    chown -R "$current_user:$current_group" "$DATA_DIR" "$LOGS_DIR" "$BUILD_DIR" "$BACKUP_DIR" "$MIGRATION_DIR"
    
    # Set directory permissions (750 for data, 755 for logs)
    find "$DATA_DIR" -type d -exec chmod 750 {} \;
    find "$LOGS_DIR" -type d -exec chmod 755 {} \;
    find "$BUILD_DIR" -type d -exec chmod 755 {} \;
    find "$BACKUP_DIR" -type d -exec chmod 750 {} \;
    find "$MIGRATION_DIR" -type d -exec chmod 750 {} \;
    
    # Set file permissions (640 for data, 644 for logs)
    find "$DATA_DIR" -type f -exec chmod 640 {} \;
    find "$LOGS_DIR" -type f -exec chmod 644 {} \;
    find "$BUILD_DIR" -type f -exec chmod 644 {} \;
    find "$BACKUP_DIR" -type f -exec chmod 640 {} \;
    find "$MIGRATION_DIR" -type f -exec chmod 640 {} \;
    
    log "SUCCESS" "Permissions set successfully"
}

# Create environment file
create_env_file() {
    log "INFO" "Creating production environment configuration..."
    
    local env_file="$PROJECT_ROOT/.env.production"
    
    cat > "$env_file" << EOF
# =============================================================================
# Crypto Coin Strategy Builder V4 - Production Environment Configuration
# =============================================================================
# Generated by setup-production-storage.sh on $(date)
# =============================================================================

# Storage Configuration
DATA_DIR=$DATA_DIR
LOGS_DIR=$LOGS_DIR
BUILD_DIR=$BUILD_DIR
BACKUP_DIR=$BACKUP_DIR
MIGRATION_DIR=$MIGRATION_DIR

# Database Configuration
D1_PATH=$DATA_DIR/database/db.sqlite
R2_ROOT=$DATA_DIR/backend/r2

# Application Configuration
NODE_ENV=production
LOG_LEVEL=warn
PORT=4000
APP_VERSION=4.0.0

# Security Configuration
API_KEY_SECRET=your-production-api-key-here
JWT_SECRET=your-production-jwt-secret-here
SESSION_SECRET=your-production-session-secret-here

# External Services
SENTRY_DSN=your-sentry-dsn-here
COINGECKO_API_KEY=your-coingecko-api-key-here

# Backup Configuration
BACKUP_RETENTION_DAYS=7
BACKUP_COMPRESSION=true
BACKUP_ENCRYPTION=false

# Monitoring Configuration
HEALTH_CHECK_INTERVAL=300
LOG_ROTATION_MAX_SIZE=100M
LOG_ROTATION_MAX_FILES=10
EOF

    chmod 640 "$env_file"
    log "SUCCESS" "Created production environment file: $env_file"
}

# Create backup script
create_backup_script() {
    log "INFO" "Creating automated backup script..."
    
    local backup_script="$PROJECT_ROOT/scripts/backup-production.sh"
    
    cat > "$backup_script" << 'EOF'
#!/bin/bash

# =============================================================================
# Crypto Coin Strategy Builder V4 - Production Backup Script
# =============================================================================
# Automated backup script for production data
# Run daily via cron: 0 2 * * * /path/to/project/scripts/backup-production.sh
# =============================================================================

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
BACKUP_DIR="${BACKUP_DIR:-./backups}"
DATA_DIR="${DATA_DIR:-./data}"
LOGS_DIR="${LOGS_DIR:-./logs}"
RETENTION_DAYS="${BACKUP_RETENTION_DAYS:-7}"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO") echo -e "${BLUE}[${timestamp}] [INFO]${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[${timestamp}] [SUCCESS]${NC} $message" ;;
        "WARNING") echo -e "${YELLOW}[${timestamp}] [WARNING]${NC} $message" ;;
        "ERROR") echo -e "${RED}[${timestamp}] [ERROR]${NC} $message" ;;
    esac
}

# Create backup
create_backup() {
    local timestamp=$(date '+%Y%m%d-%H%M%S')
    local backup_file="$BACKUP_DIR/ccsb-backup-$timestamp.tar.gz"
    
    log "INFO" "Creating backup: $backup_file"
    
    # Create backup archive
    tar -czf "$backup_file" \
        --exclude="$DATA_DIR/backend/r2/temp" \
        --exclude="$LOGS_DIR/backend/*.log" \
        --exclude="$BUILD_DIR" \
        "$DATA_DIR" "$LOGS_DIR"
    
    # Verify backup
    if tar -tzf "$backup_file" > /dev/null 2>&1; then
        log "SUCCESS" "Backup created successfully: $(du -h "$backup_file" | cut -f1)"
    else
        log "ERROR" "Backup verification failed"
        rm -f "$backup_file"
        exit 1
    fi
}

# Clean old backups
cleanup_old_backups() {
    log "INFO" "Cleaning up backups older than $RETENTION_DAYS days"
    
    local deleted_count=0
    while IFS= read -r -d '' file; do
        rm -f "$file"
        ((deleted_count++))
    done < <(find "$BACKUP_DIR" -name "ccsb-backup-*.tar.gz" -mtime +$RETENTION_DAYS -print0)
    
    if [[ $deleted_count -gt 0 ]]; then
        log "SUCCESS" "Deleted $deleted_count old backup(s)"
    else
        log "INFO" "No old backups to delete"
    fi
}

# Main execution
main() {
    log "INFO" "Starting production backup process"
    
    # Check if backup directory exists
    if [[ ! -d "$BACKUP_DIR" ]]; then
        log "ERROR" "Backup directory does not exist: $BACKUP_DIR"
        exit 1
    fi
    
    # Create backup
    create_backup
    
    # Cleanup old backups
    cleanup_old_backups
    
    log "SUCCESS" "Backup process completed successfully"
}

# Run main function
main "$@"
EOF

    chmod +x "$backup_script"
    log "SUCCESS" "Created backup script: $backup_script"
}

# Create health check script
create_health_script() {
    log "INFO" "Creating storage health check script..."
    
    local health_script="$PROJECT_ROOT/scripts/check-storage-health.sh"
    
    cat > "$health_script" << 'EOF'
#!/bin/bash

# =============================================================================
# Crypto Coin Strategy Builder V4 - Storage Health Check Script
# =============================================================================
# Script to check the health and status of production storage
# Run manually or via cron for monitoring
# =============================================================================

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
DATA_DIR="${DATA_DIR:-./data}"
LOGS_DIR="${LOGS_DIR:-./logs}"
BACKUP_DIR="${BACKUP_DIR:-./backups}"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO") echo -e "${BLUE}[${timestamp}] [INFO]${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[${timestamp}] [SUCCESS]${NC} $message" ;;
        "WARNING") echo -e "${YELLOW}[${timestamp}] [WARNING]${NC} $message" ;;
        "ERROR") echo -e "${RED}[${timestamp}] [ERROR]${NC} $message" ;;
    esac
}

# Check directory permissions
check_permissions() {
    log "INFO" "Checking directory permissions..."
    
    local dirs=("$DATA_DIR" "$LOGS_DIR" "$BACKUP_DIR")
    local all_good=true
    
    for dir in "${dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            local perms=$(stat -c "%a" "$dir")
            local owner=$(stat -c "%U:%G" "$dir")
            
            if [[ "$dir" == "$LOGS_DIR" ]]; then
                if [[ $((10#$perms)) -eq 755 ]]; then
                    log "SUCCESS" "Directory permissions: $perms ($owner) - $dir"
                else
                    log "WARNING" "Directory permissions: $perms ($owner) - $dir (expected 755)"
                    all_good=false
                fi
            else
                if [[ $((10#$perms)) -eq 750 ]]; then
                    log "SUCCESS" "Directory permissions: $perms ($owner) - $dir"
                else
                    log "WARNING" "Directory permissions: $perms ($owner) - $dir (expected 750)"
                    all_good=false
                fi
            fi
        else
            log "ERROR" "Directory not found: $dir"
            all_good=false
        fi
    done
    
    if [[ "$all_good" == true ]]; then
        log "SUCCESS" "Directory permissions check completed"
    else
        log "WARNING" "Some permission issues found"
    fi
}

# Check storage usage
check_storage_usage() {
    log "INFO" "Checking storage usage..."
    
    if [[ -d "$DATA_DIR" ]]; then
        local total_size=$(du -sh "$DATA_DIR" 2>/dev/null | cut -f1 || echo "0")
        log "SUCCESS" "Total data size: $total_size"
        
        # Check database size
        if [[ -f "$DATA_DIR/database/db.sqlite" ]]; then
            local db_size=$(du -h "$DATA_DIR/database/db.sqlite" | cut -f1)
            log "SUCCESS" "Database: $db_size"
        else
            log "WARNING" "Database file not found"
        fi
        
        # Check R2 files
        if [[ -d "$DATA_DIR/backend/r2" ]]; then
            local r2_count=$(find "$DATA_DIR/backend/r2" -type f | wc -l)
            log "SUCCESS" "R2 Files: $r2_count"
        else
            log "WARNING" "R2 directory not found"
        fi
    else
        log "ERROR" "Data directory not found"
    fi
}

# Check backup status
check_backup_status() {
    log "INFO" "Checking backup status..."
    
    if [[ -d "$BACKUP_DIR" ]]; then
        local backup_count=$(find "$BACKUP_DIR" -name "ccsb-backup-*.tar.gz" | wc -l)
        local latest_backup=$(find "$BACKUP_DIR" -name "ccsb-backup-*.tar.gz" -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
        
        if [[ $backup_count -gt 0 ]]; then
            log "SUCCESS" "Backup count: $backup_count"
            if [[ -n "$latest_backup" ]]; then
                local backup_age=$(find "$latest_backup" -printf '%AY-%Am-%Ad %AH:%AM\n' 2>/dev/null)
                log "SUCCESS" "Latest backup: $backup_age"
            fi
        else
            log "WARNING" "No backups found"
        fi
    else
        log "ERROR" "Backup directory not found"
    fi
}

# Check disk space
check_disk_space() {
    log "INFO" "Checking disk space..."
    
    local disk_usage=$(df -h . | tail -1)
    local available=$(echo "$disk_usage" | awk '{print $4}')
    local usage_percent=$(echo "$disk_usage" | awk '{print $5}' | sed 's/%//')
    
    if [[ $usage_percent -lt 80 ]]; then
        log "SUCCESS" "Disk space: $available available ($usage_percent% used)"
    elif [[ $usage_percent -lt 90 ]]; then
        log "WARNING" "Disk space: $available available ($usage_percent% used)"
    else
        log "ERROR" "Disk space critical: $available available ($usage_percent% used)"
    fi
}

# Main execution
main() {
    log "INFO" "Starting storage health check"
    
    check_permissions
    check_storage_usage
    check_backup_status
    check_disk_space
    
    log "SUCCESS" "Storage health check completed"
}

# Run main function
main "$@"
EOF

    chmod +x "$health_script"
    log "SUCCESS" "Created health check script: $health_script"
}

# Create Docker Compose override
create_docker_override() {
    log "INFO" "Creating Docker Compose production override..."
    
    local override_file="$PROJECT_ROOT/docker-compose.prod.override.yml"
    
    cat > "$override_file" << EOF
# =============================================================================
# Crypto Coin Strategy Builder V4 - Production Docker Compose Override
# =============================================================================
# Generated by setup-production-storage.sh on $(date)
# Extends docker-compose.prod.yml with storage-specific configurations
# =============================================================================

version: '3.8'

services:
  backend:
    volumes:
      - backend_data:/app/data
      - backend_logs:/app/logs
      - backup_data:/app/backups
      - migration_data:/app/migrations
    environment:
      - NODE_ENV=production
      - DATA_DIR=/app/data
      - LOGS_DIR=/app/logs
      - BACKUP_DIR=/app/backups
      - MIGRATION_DIR=/app/migrations
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '2.0'
        reservations:
          memory: 1G
          cpus: '1.0'
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  database:
    volumes:
      - database_data:/data
      - backup_data:/backups:ro
      - ./drizzle:/drizzle:ro
    environment:
      - SQLITE_DB_PATH=/data/db.sqlite
      - BACKUP_DIR=/backups
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'
    healthcheck:
      test: ["CMD", "sqlite3", "/data/db.sqlite", "SELECT 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  nginx:
    volumes:
      - backend_logs:/var/log/nginx
      - ./nginx/ssl:/etc/nginx/ssl:ro
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

volumes:
  backend_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: \${DATA_DIR:-./data}/backend
  
  backend_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: \${LOGS_DIR:-./logs}/backend
  
  database_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: \${DATA_DIR:-./data}/database
  
  backup_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: \${BACKUP_DIR:-./backups}
  
  migration_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: \${MIGRATION_DIR:-./migrations}

networks:
  default:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
EOF

    log "SUCCESS" "Created Docker Compose override: $override_file"
}

# Display summary
display_summary() {
    log "INFO" "=========================================="
    log "SUCCESS" "Production Storage Setup Complete!"
    log "INFO" "=========================================="
    log "INFO" "Created directories:"
    log "INFO" "  - Data: $DATA_DIR"
    log "INFO" "  - Logs: $LOGS_DIR"
    log "INFO" "  - Build: $BUILD_DIR"
    log "INFO" "  - Backups: $BACKUP_DIR"
    log "INFO" "  - Migrations: $MIGRATION_DIR"
    log "INFO" ""
    log "INFO" "Created scripts:"
    log "INFO" "  - Backup: scripts/backup-production.sh"
    log "INFO" "  - Health Check: scripts/check-storage-health.sh"
    log "INFO" ""
    log "INFO" "Created configuration:"
    log "INFO" "  - Environment: .env.production"
    log "INFO" "  - Docker Override: docker-compose.prod.override.yml"
    log "INFO" ""
    log "INFO" "Next steps:"
    log "INFO" "  1. Review and customize .env.production"
    log "INFO" "  2. Set up automated backups in crontab"
    log "INFO" "  3. Deploy with: docker-compose -f docker-compose.prod.yml -f docker-compose.prod.override.yml up -d"
    log "INFO" "  4. Verify with: ./scripts/check-storage-health.sh"
    log "INFO" "=========================================="
}

# Main execution
main() {
    log "INFO" "Starting production storage setup..."
    
    # Check prerequisites
    check_root
    
    # Create storage infrastructure
    create_directories
    set_permissions
    create_env_file
    create_backup_script
    create_health_script
    create_docker_override
    
    # Display summary
    display_summary
    
    log "SUCCESS" "Production storage setup completed successfully!"
}

# Run main function
main "$@"
